"use strict";(self.webpackChunkobd_kill=self.webpackChunkobd_kill||[]).push([[606],{8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var r=i(6540);const t={},o=r.createContext(t);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(o.Provider,{value:n},e.children)}},8938:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"obd-kill-micropython-examples","title":"OBD-Kill MicroPython Examples","description":"Explore MicroPython examples for OBD-Kill, including GPIO pin control, LED signals, PWM for buzzer tones, and UART serial communication with Raspberry Pi Pico.","source":"@site/docs/obd-kill-micropython-examples.md","sourceDirName":".","slug":"/obd-kill-micropython-examples","permalink":"/docs/obd-kill/obd-kill-micropython-examples","draft":false,"unlisted":false,"editUrl":"https://github.com/intrepidcs/obd-kill-docs/blob/main/docs/obd-kill-micropython-examples.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"OBD-Kill MicroPython Examples","description":"Explore MicroPython examples for OBD-Kill, including GPIO pin control, LED signals, PWM for buzzer tones, and UART serial communication with Raspberry Pi Pico.","keywords":["OBD-Kill","MicroPython","Raspberry Pi Pico","GPIO","PWM","UART","LED control","pinout","CAN Hack","serial communication","buzzer","Pulse Width Modulation","UF2 file."],"sidebar_position":6,"sidebar_label":"OBD-Kill MicroPython Examples"},"sidebar":"tutorialSidebar","previous":{"title":"Setup","permalink":"/docs/obd-kill/hardware-and-software-setup"},"next":{"title":"CANHack MicroPython SDK","permalink":"/docs/obd-kill/canhack-micropython-sdk"}}');var t=i(4848),o=i(8453);const a={title:"OBD-Kill MicroPython Examples",description:"Explore MicroPython examples for OBD-Kill, including GPIO pin control, LED signals, PWM for buzzer tones, and UART serial communication with Raspberry Pi Pico.",keywords:["OBD-Kill","MicroPython","Raspberry Pi Pico","GPIO","PWM","UART","LED control","pinout","CAN Hack","serial communication","buzzer","Pulse Width Modulation","UF2 file."],sidebar_position:6,sidebar_label:"OBD-Kill MicroPython Examples"},s="OBD-Kill MicroPython Examples",l={},c=[{value:"5. Examples",id:"5-examples",level:2},{value:"5.1 Pin",id:"51-pin",level:3},{value:"5.2 Signal (used for LEDs)",id:"52-signal-used-for-leds",level:3},{value:"5.3 PWM \u2013 Pulse Width Modulation",id:"53-pwm--pulse-width-modulation",level:3},{value:"5.4 Serial Communication Interface",id:"54-serial-communication-interface",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"obd-kill-micropython-examples",children:"OBD-Kill MicroPython Examples"})}),"\n",(0,t.jsx)(n.h2,{id:"5-examples",children:"5. Examples"}),"\n",(0,t.jsx)(n.h3,{id:"51-pin",children:"5.1 Pin"}),"\n",(0,t.jsx)(n.p,{children:"A pin object is used to control I/O pins (also known as GPIO - general-purpose input/output). Pin objects are commonly associated with a physical pin that can drive an output voltage and read input voltages. The pin class has methods to set the mode of the pin (IN, OUT, etc) and methods to get and set the digital logic level. For analog control of a pin, see the ADC class."}),"\n",(0,t.jsx)(n.p,{children:"A pin object is constructed by using an identifier which unambiguously specifies a certain I/O pin. The allowed forms of the identifier and the physical pin that the identifier maps to are port-specific. Possibilities for the identifier are an integer, a string or a tuple with port and pin number."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from machine import Pin\r\n\r\n# create an output pin on pin #0\r\np0 = Pin(0, Pin.OUT)\r\n\r\n# set the value low then high\r\np0.value(0)\r\np0.value(1)\r\n\r\n# create an input pin on pin #2, with a pull up resistor\r\np2 = Pin(2, Pin.IN, Pin.PULL_UP)\r\n\r\n# read and print the pin value\r\nprint(p2.value())\r\n\r\n# reconfigure pin #0 in input mode with a pull down resistor\r\np0.init(p0.IN, p0.PULL_DOWN)\r\n\r\n# configure an irq callback\r\np0.irq(lambda p:print(p))\n"})}),"\n",(0,t.jsx)(n.p,{children:"Pin values can be set; however, Signals are easier to control"}),"\n",(0,t.jsx)(n.h3,{id:"52-signal-used-for-leds",children:"5.2 Signal (used for LEDs)"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://docs.micropython.org/en/latest/library/machine.Signal.html",children:"https://docs.micropython.org/en/latest/library/machine.Signal.html"})}),"\n",(0,t.jsx)(n.p,{children:"The Signal class is a simple extension of the Pin class. Unlike Pin, which can be only in \u201cabsolute\u201d 0 and 1 states, a Signal can be in \u201casserted\u201d (on) or \u201cdeasserted\u201d (off) states, while being inverted (active-low) or not. In other words, it adds logical inversion support to Pin functionality. While this may seem a simple addition, it is exactly what is needed to support wide array of simple digital devices in a way portable across different boards, which is one of the major MicroPython goals. Regardless of whether different users have an active-high or active-low LED, a normally open or normally closed relay - you can develop a single, nicely looking application which works with each of them, and capture hardware configuration differences in few lines in the config file of your app."}),"\n",(0,t.jsx)(n.p,{children:"The following example shows how to create signals to control the inner LED on both eyes of the OBD-Kill"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from machine import Signal\r\nimport utime\r\n \r\nrightMiddlePin = Pin(10, Pin.OUT)\r\n \r\nrightMiddleLED = Signal(rightMiddlePin)\r\n \r\n# can combine constructor to one \r\nleftMiddleLED = Signal(Pin(26, Pin.OUT)\r\n \r\nrightMiddleLED.on()\r\nleftMiddleLED.off()\r\n \r\n# .value() returns the status of the LED (On=1, Off=0)\r\nprint(rightMiddleLED.value()) # will print 1\r\nprint(leftMiddleLED.value()) # will print 0\r\n \r\n \r\n# alternate flashing each green LED every second\r\nwhile True:\r\n  rightMiddleLED.on()\r\n  leftMiddleLED.off()\r\n  utime.sleep_ms(1000)\r\n   \r\n  rightMiddleLED.on()\r\n  leftMiddleLED.off()\r\n  utime.sleep_ms(1000)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"53-pwm--pulse-width-modulation",children:"5.3 PWM \u2013 Pulse Width Modulation"}),"\n",(0,t.jsx)(n.p,{children:"This class provides pulse width modulation output"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://docs.micropython.org/en/latest/library/machine.PWM.html",children:"https://docs.micropython.org/en/latest/library/machine.PWM.html"})}),"\n",(0,t.jsx)(n.p,{children:"Here is a Map that contains the pitches and their corresponding frequencies. See the next example to see how to access the frequency."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'tones = {"B0": 31, "C1": 33, "CS1": 35, "D1": 37, "DS1": 39, "E1": 41, "F1": 44, "FS1": 46, "G1": 49, "GS1": 52,\r\n"A1": 55, "AS1": 58, "B1": 62, "C2": 65, "CS2": 69, "D2": 73, "DS2": 78, "E2": 82, "F2": 87, "FS2": 93, "G2": 98,\r\n"GS2": 104, "A2": 110, "AS2": 117, "B2": 123, "C3": 131, "CS3": 139, "D3": 147, "DS3": 156, "E3": 165, "F3": 175,\r\n"FS3": 185, "G3": 196, "GS3": 208, "A3": 220, "AS3": 233, "B3": 247,"C4": 262, "CS4": 277, "D4": 294, "DS4": 311,\r\n"E4": 330, "F4": 349, "FS4": 370, "G4": 392, "GS4": 415, "A4": 440, "AS4": 466, "B4": 494, "C5": 523, "CS5": 554,\r\n"D5": 587, "DS5": 622, "E5": 659, "F5": 698, "FS5": 740, "G5": 784, "GS5": 831, "A5": 880, "AS5": 932, "B5": 988,\r\n"C6": 1047, "CS6": 1109, "D6": 1175, "DS6": 1245,"E6": 1319, "F6": 1397, "FS6": 1480, "G6": 1568, "GS6": 1661,\r\n"A6": 1760, "AS6": 1865, "B6": 1976, "C7": 2093, "CS7": 2217, "D7": 2349, "DS7": 2489, "E7": 2637, "F7": 2794,\r\n"FS7": 2960, "G7": 3136, "GS7": 3322, "A7": 3520, "AS7": 3729, "B7": 3951, "C8": 4186, "CS8": 4435, "D8": 4699,\r\n"DS8": 4978, "rest": -1}py\n'})}),"\n",(0,t.jsx)(n.p,{children:"The duty cycle is set by using the .duty_u16() method. This value is divided by 65535 to calculate the duty cycle. A larger number corresponds with a louder volume."}),"\n",(0,t.jsx)(n.admonition,{title:"Warning",type:"warning",children:(0,t.jsx)(n.p,{children:"Use caution when programming large duty cycles. Loud sounds may cause hearing damage. For these examples, the duty cycle will never exceed 1000."})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'buzzer.freq(tones["C5"]) # set the frequency to match pitch C5\r\nbuzzer.duty_u16(2000) # set the duty cycle for the pulses to be 1000/65535=1.5%\n'})}),"\n",(0,t.jsx)(n.p,{children:"Increase the volume (duty cycle) for 3 seconds, hold for 3 seconds, decrease the volume for 3 seconds"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"for i in range(0, 1000):\r\n        buzzer.duty_u16(i)\r\n        utime.sleep_ms(3)\r\n \r\nutime.sleep_ms(3000)\r\n \r\nfor i in reversed(range(0, 1000)):\r\n        buzzer.duty_u16(i)\r\n        utime.sleep_ms(3)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"54-serial-communication-interface",children:"5.4 Serial Communication Interface"}),"\n",(0,t.jsx)(n.p,{children:"UART implements the standard UART/USART duplex serial communications protocol. At the physical level it consists of 2 lines: RX and TX. The unit of communication is a character (not to be confused with a string character) which can be 8 or 9 bits wide."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://docs.micropython.org/en/latest/library/machine.UART.html",children:"https://docs.micropython.org/en/latest/library/machine.UART.html"})}),"\n",(0,t.jsx)(n.p,{children:"UART objects can be created and initialised using:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from machine import UART\r\n\r\nuartOne = UART(1, baudrate=9600, tx=Pin(4), rx=Pin(5)) # GP4 is the standard Pin for and transmitting messages is the standard Pin for receiving\n"})}),"\n",(0,t.jsx)(n.p,{children:"A UART object acts like a stream object and reading and writing is done using the standard stream methods:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"uart.read(10)       # read 10 characters, returns a bytes object\r\nuart.read()         # read all available characters\r\nuart.readline()     # read a line\r\nuart.readinto(buf)  # read and store into the given buffer\r\nuart.write('abc')   # write the characters 'a', 'b', and 'c'\n"})}),"\n",(0,t.jsx)(n.p,{children:"A function to transmit a user-defined message on a specified interval:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'import utime\r\nfrom machine import UART\r\n\r\ndef transmitMessages(occurances, timeBetween, message):\r\n    for i in range(occurances):\r\n        uart.write(message + "\\n")\r\n        utime.sleep_ms(timeBetween)\r\n        \r\ntransmitMessages(5, 50, "Test") # transmit the message "Test" 5 times with 50 seconds between each message\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);