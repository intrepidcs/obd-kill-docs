"use strict";(self.webpackChunkobd_kill=self.webpackChunkobd_kill||[]).push([[593],{1516:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"canhack-micropython-sdk","title":"CANHack MicroPython SDK","description":"CANHack MicroPython SDK enables CAN bus security testing on Raspberry Pi Pico, supporting attacks like spoofing, bus-off, and error injection for research.","source":"@site/docs/canhack-micropython-sdk.md","sourceDirName":".","slug":"/canhack-micropython-sdk","permalink":"/docs/obd-kill/canhack-micropython-sdk","draft":false,"unlisted":false,"editUrl":"https://github.com/intrepidcs/obd-kill-docs/blob/main/docs/canhack-micropython-sdk.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"CANHack MicroPython SDK","description":"CANHack MicroPython SDK enables CAN bus security testing on Raspberry Pi Pico, supporting attacks like spoofing, bus-off, and error injection for research.","keywords":["CANHack","MicroPython","SDK","CAN bus","security testing","Raspberry Pi Pico","spoofing","bus-off","error injection"],"sidebar_position":7,"sidebar_label":"CANHack MicroPython SDK"},"sidebar":"tutorialSidebar","previous":{"title":"OBD-Kill MicroPython Examples","permalink":"/docs/obd-kill/obd-kill-micropython-examples"},"next":{"title":"Support Contact Information","permalink":"/docs/obd-kill/support-contact-information"}}');var s=n(4848),i=n(8453);const o={title:"CANHack MicroPython SDK",description:"CANHack MicroPython SDK enables CAN bus security testing on Raspberry Pi Pico, supporting attacks like spoofing, bus-off, and error injection for research.",keywords:["CANHack","MicroPython","SDK","CAN bus","security testing","Raspberry Pi Pico","spoofing","bus-off","error injection"],sidebar_position:7,sidebar_label:"CANHack MicroPython SDK"},a="CANHack MicroPython SDK",h={},c=[{value:"6. CANHack MicroPython SDK",id:"6-canhack-micropython-sdk",level:3},{value:"6.1 Introduction",id:"61-introduction",level:3},{value:"6.2 CANHack Python API",id:"62-canhack-python-api",level:3},{value:"6.3 Quick start",id:"63-quick-start",level:3}];function l(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"canhack-micropython-sdk",children:"CANHack MicroPython SDK"})}),"\n",(0,s.jsx)(t.h3,{id:"6-canhack-micropython-sdk",children:"6. CANHack MicroPython SDK"}),"\n",(0,s.jsx)(t.h3,{id:"61-introduction",children:"6.1 Introduction"}),"\n",(0,s.jsxs)(t.p,{children:["There are two ways to mount an attack on a CAN bus. The simplest is a ",(0,s.jsx)(t.em,{children:"frame attack"}),": to use existing CAN hardware \u2013 the CAN controller \u2013 to send frames on the bus. For example, to send a spoof frame. Or to send frames at such a rate that legitimate frames are slowed or prevented: a ",(0,s.jsx)(t.em,{children:"flood attack"})," (in a real-time system, a message arriving late is a failure of the system). The other way to mount an attack is to by-pass the CAN hardware and drive carefully crafted signals directly on to the bus: a CAN ",(0,s.jsx)(t.em,{children:"protocol attack"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"A CAN protocol attack uses software to drive signals that exploit low-level features of the CAN protocol itself. For example, the Bus Off attack uses the CAN error confinement rules to disconnect a targeted ECU from the bus. A CAN protocol attack uses direct access to the standard component that all ECUs contain: the CAN transceiver. The transceiver is a chip that converts between the digital TX and RX I/O from the CAN controller and the analog voltages of CAN H and CAN L on the twisted pair CAN wire. Normally the TX and RX pins are driven by a CAN controller but in most ECU electronics this controller is integrated inside a single microcontroller chip alongside the CPU, RAM, etc. But software can disable the CAN controller and take control of the I/O pins directly (using the pin mux that is present in some form on all microcontrollers)."}),"\n",(0,s.jsx)("div",{class:"text--center",children:(0,s.jsxs)("figure",{children:[(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"mc",src:n(3393).A+"",title:"mc",width:"386",height:"168"})}),(0,s.jsx)("figcaption",{})]})}),"\n",(0,s.jsx)(t.p,{children:"With carefully written software it is possible to drive the TX pin quickly enough to emulate parts of the CAN protocol and mount protocol attacks. The CANHack toolkit is designed to prove that this is a viable attack mechanism."}),"\n",(0,s.jsx)(t.p,{children:"The CANHack software is provided as generic C that \u2018bit bangs\u2019 the TX pin using spin loops. It has been ported to the RP2040 microcontroller in the Raspberry Pi Pico and been wrapped with a Python API in custom MicroPython firmware for the Raspberry Pi Pico, and firmware is provided for three different boards:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The Canis Labs (canislabs.com) CANPico board1, that has a CAN transceiver shared with a Microchip MCP2517FD CAN controller connected over SPI."}),"\n",(0,s.jsx)(t.li,{children:"The Canis Labs CANHack board."}),"\n",(0,s.jsx)(t.li,{children:"The Car Hacking Village DEF CON 30 badge from Intrepid Control Systems (intrepidcs.com)"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The generic C and the MicroPython API code are available in the Canis Labs repository: ",(0,s.jsx)(t.a,{href:"https://github.com/kentindell/canhack",children:"https://github.com/kentindell/canhack"})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["See ",(0,s.jsx)(t.a,{href:"https://kentindell.github.io/2021/05/24/canpico-intro/",children:"https://kentindell.github.io/2021/05/24/canpico-intro/"})," for more about the CANPico"]})}),"\n",(0,s.jsx)(t.p,{children:"The CANHack toolkit attacks implements the following attacks:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Targeted and overwrite spoofing attacks"}),"\n",(0,s.jsx)(t.li,{children:"Bus Off attack"}),"\n",(0,s.jsx)(t.li,{children:"Error Passive attack"}),"\n",(0,s.jsx)(t.li,{children:"Janus2 attack"}),"\n",(0,s.jsx)(t.li,{children:"Double Receive3 attack"}),"\n",(0,s.jsx)(t.li,{children:"Freeze Doom Loop4 attack"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The API also contains diagnostic functions for setting the bus to dominant or recessive, putting a square wave on to the bus, and sending a defined CAN frame."}),"\n",(0,s.jsx)(t.p,{children:"As well as providing the CANHack toolkit API there are some other features included in the firmware:"}),"\n",(0,s.jsx)(t.p,{children:"- A second USB serial port is included (so when the Pico connects to a host, two virtual ports are instantiated5)."}),"\n",(0,s.jsx)(t.p,{children:"- An implementation of the MIN (Microcontroller Interconnect Network) protocol6."}),"\n",(0,s.jsx)(t.p,{children:"Before going any further there is an important caveat:"}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)("span",{class:"custom-link",children:[(0,s.jsx)(t.strong,{children:"WARNING"})," ",(0,s.jsx)("br",{})," Connecting the CAN hardware directly to a vehicle CAN bus comes with risk and should not be undertaken without understanding this risk. Grounding a vehicle chassis through the USB port of a Pico connected to a laptop, PC or USB hub powered from the mains may cause permanent damage to the vehicle\u2019s electronics and/or the Raspberry Pi Pico and devices it is connected to. The CAN transceiver will tolerate a ground potential difference (\u201cground offset\u201d) of between -2V/+7V. Connecting pin 2 of the screw terminal to the target system\u2019s ground will establish a common ground reference. The CAN bus must be properly terminated (with 120W resistors at either end). If the CAN bus is already terminated at both ends then the termination on the board should not be engaged. In addition, causing disruption to a vehicle\u2019s CAN bus traffic may be interpreted by the vehicle fault management systems as a hardware fault and cause the vehicle to permanently shut down CAN communications with consequent loss of functionality."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"62-canhack-python-api",children:"6.2 CANHack Python API"}),"\n",(0,s.jsxs)(t.p,{children:["The CANHack toolkit is provided as a single class ",(0,s.jsx)(t.code,{children:"CANHack"}),"."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"6.2.1 CANHack \u2014 CANHack toolkit"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"class CANHack"}),"( [ ",(0,s.jsx)(t.em,{children:"bitrate"}),"=",(0,s.jsx)(t.em,{children:"500"})," ] )"]}),"\n",(0,s.jsx)(t.p,{children:"Initializes the CANHack toolkit."}),"\n",(0,s.jsx)(t.admonition,{title:"info",type:"danger",children:(0,s.jsx)("span",{class:"custom-link",children:"If running on a CANPico, this constructor must be called after the CAN controller TX output is put into open drain mode (by setting the CAN controller tx_open_drain parameter to True)."})}),"\n",(0,s.jsx)(t.p,{children:"Raises"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.em,{children:(0,s.jsx)(t.code,{children:"ValueError"})})," \u2013 if bit_rate is not one of 500, 250, or 125"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Methods"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"set_frame"}),(0,s.jsx)(t.em,{children:"([can_id=0x7ff] [, remote=False] [, extended=False] [, data=None] [, set_dlc=False] [, dlc=0] [, second=False] )"})]}),"\n",(0,s.jsx)(t.p,{children:"Set the specified frame buffer."}),"\n",(0,s.jsx)(t.p,{children:"The frame buffer is an internal buffer in RAM in the toolkit that pre-defines the bit sequence for a CAN frame (pre-calculating where the stuff bits go, etc.)"}),"\n",(0,s.jsx)(t.p,{children:"This function pre-computes the layout of a CAN frame into a frame buffer inside the toolkit (it will set the shadow frame buffer is second is True because the Janus Attack7 requires two separate CAN frames)."}),"\n",(0,s.jsx)(t.p,{children:"This method must be called prior to mounting an attack: the pre-computed bit pattern in the frame buffer is used to synchronize the attack on a targeted frame."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"can_id"})," (",(0,s.jsx)(t.em,{children:"int"}),")\u2013 An 11-bit or 29-bit integer representing the CAN ID of the frame"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"remote"})," (",(0,s.jsx)(t.em,{children:"bool"}),") \u2013 True if the frame is a remote frame"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"extended"})," (",(0,s.jsx)(t.em,{children:"bool"}),") \u2013 True if can_id is a 29-bit CAN identifier"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"data"})," (",(0,s.jsx)(t.em,{children:"bytes"}),") \u2013 The payload of the CAN frame"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"set_dlc"})," (",(0,s.jsx)(t.em,{children:"bool"}),") \u2013 True if the DLC should be set to a specific value"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"dlc"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 the value of DLC if set_dlc is True"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"second"})," (",(0,s.jsx)(t.em,{children:"bool"}),") \u2013 True if this call is setting the shadow frame in preparation for the Janus Attack"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Raises"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ValueError"})," \u2013 if the ",(0,s.jsx)(t.em,{children:"dlc"})," value is > 15 or if the payload is more than 8 bytes or remote is ",(0,s.jsx)(t.em,{children:"True"})," and ",(0,s.jsx)(t.em,{children:"data"})," is set"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["For more details on the Janus Attack see: ",(0,s.jsx)(t.a,{href:"https://kentindell.github.io/2020/01/20/new-can-hacks/",children:"https://kentindell.github.io/2020/01/20/new-can-hacks/"})]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Returns"})," ",(0,s.jsx)(t.em,{children:"None"})]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"get_frame"}),"( [, ",(0,s.jsx)(t.em,{children:"second=False"}),"] )"]}),"\n",(0,s.jsx)(t.p,{children:"Return details of the specified frame buffer."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"second"})," (",(0,s.jsx)(t.em,{children:"bool"}),") \u2013 ",(0,s.jsx)(t.em,{children:"True"})," if the details of the shadow frame buffer should be returned"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Return type"})," tuple\r\n",(0,s.jsx)(t.strong,{children:"Raises"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ValueError"})," \u2013 if the selected frame buffer has not been set by a prior call to ",(0,s.jsx)(t.em,{children:"set_frame"}),"()"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The method returns an 8-element tuple of:"}),"\n",(0,s.jsx)(t.p,{children:"- A string representing the frame bitstream (including stuff bits) with '1' and '0' characters for the bits"}),"\n",(0,s.jsx)(t.p,{children:"- A string representing where the stuff bits are located (with 'X' being a stuff bit and '\u2013' being a data bit)"}),"\n",(0,s.jsx)(t.p,{children:"- The integer index of the last arbitration bit in the bitstream"}),"\n",(0,s.jsx)(t.p,{children:"- The integer index of the last DLC bit in the bitstream"}),"\n",(0,s.jsx)(t.p,{children:"- The integer index of the last data bit in the bitstream"}),"\n",(0,s.jsx)(t.p,{children:"- The integer index of the last CRC bit in the bitstream"}),"\n",(0,s.jsx)(t.p,{children:"- The integer index of the last EOF bit in the bitstream"}),"\n",(0,s.jsx)(t.p,{children:"- A 15-bit integer of the CRC of the frame"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"send_frame"}),"([",(0,s.jsx)(t.em,{children:"timeout"}),"=",(0,s.jsx)(t.em,{children:"50000000"}),"] [, ",(0,s.jsx)(t.em,{children:"second"}),"=",(0,s.jsx)(t.em,{children:"False"}),"] [, ",(0,s.jsx)(t.em,{children:"retries"}),"=0])"]}),"\n",(0,s.jsx)(t.p,{children:"Send a frame on the CAN bus."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"timeout"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 A value for how long we wait for bus idle before giving up"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"second"})," (",(0,s.jsx)(t.em,{children:"bool"}),") \u2013 True if the frame should come from the shadow frame buffer"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"retries"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 the number of times to try again to send the frame after loss of arbitration or error"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Raises"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ValueError"})," \u2013 if the selected frame buffer has not been set by a prior call to ",(0,s.jsx)(t.em,{children:"set_frame"}),"()"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This function sends the specified frame on the CAN bus. It waits for the bus to become idle and then starts transmitting, following the CAN protocol for arbitration. If it loses arbitration or detects an error then it tries again, up to a maximum set by retries."}),"\n",(0,s.jsx)(t.p,{children:"This function can mount a traditional spoof attack on the bus where the frame pretends to be from another node, avoiding the 'doom loop' problem with this being mounted from a standard CAN controller (the 'doom loop' happens if the spoof frame and the legitimate frame happen to win arbitration at the same time: an error will be raised and arbitration will re-start and his will continue in a loop until one of the devices has gone error passive or bus-off)."}),"\n",(0,s.jsx)(t.p,{children:"The timeout value is used as a limit on spin looping and depends on the target CPU. For the RP2040 in the Raspberry Pi Pico a timeout value of 3440000 is one second of real-time."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"send_janus_frame"}),"([",(0,s.jsx)(t.em,{children:"timeout"}),"=",(0,s.jsx)(t.em,{children:"50000000"}),"] [, ",(0,s.jsx)(t.em,{children:"sync_time"}),"=",(0,s.jsx)(t.em,{children:"50"}),"] [, ",(0,s.jsx)(t.em,{children:"split_time"}),"=",(0,s.jsx)(t.em,{children:"155"}),"], [, ",(0,s.jsx)(t.em,{children:"retries"}),"=",(0,s.jsx)(t.em,{children:"0"}),"])"]}),"\n",(0,s.jsx)(t.p,{children:"Sends the specified Janus frame on the CAN bus."}),"\n",(0,s.jsxs)(t.p,{children:["It waits for the bus to become idle and then starts transmitting, following the CAN protocol for arbitration. If it loses arbitration or detects an error then it tries again, up to a maximum set by ",(0,s.jsx)(t.em,{children:"retries"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"A Janus frame is a CAN frame with two different contents, specified by the frame buffer and shadow frame buffer. It must have the same ID and be the same number of bits long, which means it must have the same number of stuff bits (although they can be in different places)."}),"\n",(0,s.jsxs)(t.p,{children:["There is a Python tool in the Canis Labs CANHack repository (",(0,s.jsx)(t.a,{href:"https://github.com/kentindell/canhack",children:"https://github.com/kentindell/canhack"}),") in ",(0,s.jsx)(t.em,{children:"src/canframe.py"}),". The function ",(0,s.jsx)(t.strong,{children:"is_janus()"})," indicates if two frames are \u2018Janus compatible\u2019: checking the length is the same and also the transitions cause the CAN protocol engines in the receivers to sync correctly. There is also code that does a search for compatible Janus frames."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"timeout"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 The timeout (a value of 50000000 corresponds to about 17 seconds on the Raspberry Pi Pico)"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"sync_time"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 The number of clock ticks to wait to ensure controllers have synced"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"split_time"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 The number of clock ticks from the start of the bit before the second CAN bit value is set"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"retries"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 the number of times to try to send the frame after loss of arbitration or error"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Raises"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ValueError"})," \u2013 if either frame buffer has not been set by a prior call to ",(0,s.jsx)(t.em,{children:"set_frame"}),"()"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"spoof_frame"}),"([",(0,s.jsx)(t.em,{children:"timeout"}),"=",(0,s.jsx)(t.em,{children:"50000000"}),"] [, ",(0,s.jsx)(t.em,{children:"overwrite"}),"=",(0,s.jsx)(t.em,{children:"False"}),"] [, ",(0,s.jsx)(t.em,{children:"retries"}),"=0])"]}),"\n",(0,s.jsx)(t.p,{children:"Target a frame and send a spoof version."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"timeout"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 The time to wait for the targeted frame to appear before giving up"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"overwrite"})," (",(0,s.jsx)(t.em,{children:"bool"}),") \u2013 Once the targeted frame has been detected, overwrite the remainder with the selected spoof frame "]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"retries"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 the number of times to try to send the frame after loss of arbitration or error"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Returns"})," ",(0,s.jsx)(t.em,{children:"None"})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Raises"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"ValueError"})," \u2013 if the frame buffer has not been set by a prior call to ",(0,s.jsx)(t.em,{children:"set_frame"}),"()"]}),"\n",(0,s.jsxs)(t.p,{children:["If ",(0,s.jsx)(t.em,{children:"overwrite"})," is True then the spoof frame is written over the top of the targeted frame. If the targeted sender is error passive then it will not be able to signal an error frame and other controllers will receive only the spoofed version of the frame. If ",(0,s.jsx)(t.em,{children:"overwrite"})," is set to ",(0,s.jsx)(t.em,{children:"False"})," then the spoof frame is entered into arbitration immediately following the end of the targeted frame."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"error_attack"}),"([",(0,s.jsx)(t.em,{children:"repeat"}),"=",(0,s.jsx)(t.em,{children:"2"}),"] [, ",(0,s.jsx)(t.em,{children:"timeout"}),"=",(0,s.jsx)(t.em,{children:"50000000"}),"])"]}),"\n",(0,s.jsx)(t.p,{children:"Repeatedly destroy a targeted frame with error frames."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"timeout"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 The time to wait for the targeted frame to appear before giving up"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"repeat"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 the number of times to repeat the attack"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Returns"})," ",(0,s.jsx)(t.em,{children:"True"})," if the timeout occurred, ",(0,s.jsx)(t.em,{children:"False"})," otherwise"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Return type"})," bool\r\n",(0,s.jsx)(t.strong,{children:"Raises"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ValueError"})," \u2013 if the frame buffer has not been set by a prior call to ",(0,s.jsx)(t.em,{children:"set_frame"}),"()"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["A CAN frame with the targeted frame's ID must be set using the ",(0,s.jsx)(t.em,{children:"set_frame"}),"() before calling this method. When the ID of the targeted CAN frame has been seen then an error is generated (six dominant bits) and all CAN controllers go into error handling. The error delimiter is targeted for further repeating of the attack. With this approach a targeted node can quickly be driven into the error passive or bus- off state."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"double_receive_attack"}),"([",(0,s.jsx)(t.em,{children:"repeat=2"}),"] [, ",(0,s.jsx)(t.em,{children:"timeout"}),"=",(0,s.jsx)(t.em,{children:"50000000"}),"])"]}),"\n",(0,s.jsx)(t.p,{children:"Cause a targeted frame to be received twice."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"timeout"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 The time to wait for the targeted frame to appear before giving up"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"repeat"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 the number of times to repeat the attack"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Returns"})," ",(0,s.jsx)(t.em,{children:"True"})," if the timeout occurred, False otherwise"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Return type"})," bool\r\n",(0,s.jsx)(t.strong,{children:"Raises"})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ValueError"})," \u2013 if the frame buffer has not been set by a prior call to ",(0,s.jsx)(t.em,{children:"set_frame"}),"()"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["A CAN frame with the targeted frame's ID must be set using the ",(0,s.jsx)(t.em,{children:"set_frame"}),"() before calling this method. When the ID of the targeted CAN frame has been seen then an error is generated at the last bit of the EOF field, after the receivers have accepted the CAN frame but before the transmitter has marked it as sent. This causes the transmitter to signal an error and retransmit the frame, leading to it being received twice."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"freeze_doom_loop_attack"}),"([repeat=",(0,s.jsx)(t.em,{children:"2"}),"] [, ",(0,s.jsx)(t.em,{children:"timeout"}),"=",(0,s.jsx)(t.em,{children:"50000000"}),"])"]}),"\n",(0,s.jsx)(t.p,{children:"Freeze the bus after a targeted frame has been successfully transmitted."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"timeout"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 The number of bit times to wait for the targeted frame to appear before giving up"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"repeat"})," (",(0,s.jsx)(t.em,{children:"int"}),") \u2013 the number of times to repeat the attack"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Returns"})," ",(0,s.jsx)(t.em,{children:"None"})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Raises"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"ValueError"})})," \u2013 if the frame buffer has not been set by a prior call to ",(0,s.jsx)(t.em,{children:"set_frame"}),"()"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"A CAN frame with the targeted frame's ID must be set using the set_frame() before calling this method. When the ID of the targeted CAN frame has been seen then an overload frame is generated after the last bit of the EOF field, after the receivers have accepted the CAN frame and the transmitter has marked it as sent. This causes the controllers to enter the overload frame recovery mode (like error recovery, except the error counters are not incremented). At the end of the error delimiter, another overload frame is generated until the number in the repeat parameter is reached."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"set_can_tx"}),"( [ ",(0,s.jsx)(t.em,{children:"recessive"}),"=",(0,s.jsx)(t.em,{children:"True"})," ] )"]}),"\n",(0,s.jsxs)(t.p,{children:["(",(0,s.jsx)(t.em,{children:"Hardware diagnostic method"}),") Set the CAN TX pin to recessive or dominant."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"recessive"})," (",(0,s.jsx)(t.em,{children:"bool"}),") \u2013 Set to True if the TX pin should be set recessive (i.e. high)"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Returns"})," ",(0,s.jsx)(t.em,{children:"True"})," if CAN RX was recessive, ",(0,s.jsx)(t.em,{children:"False"})," otherwise"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Return type"})," bool"]}),"\n",(0,s.jsx)(t.p,{children:"This is intended for diagnostics to check that the TX and RX pins have been identified and connected correctly."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"square_wave()"})}),"\n",(0,s.jsxs)(t.p,{children:["(",(0,s.jsx)(t.em,{children:"Hardware diagnostic method"}),") Drive the CAN TX pin for 160 CAN bit times with a square wave with a 50:50 duty cycle and a frequency of half the CAN bit rate."]}),"\n",(0,s.jsx)(t.p,{children:"The purpose of this function is for hardware bring-up to check that the CAN TX pin is driven correctly."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Return type"})," ",(0,s.jsx)(t.em,{children:"None"})]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"loopback()"})," (",(0,s.jsx)(t.em,{children:"Hardware diagnostic method"}),") Wait for a falling edge on CAN RX and then drive the TRIG pin with the value of CAN RX for 160 bit times."]}),"\n",(0,s.jsx)(t.p,{children:"The purpose of this function is for hardware bring-up to check that the CAN RX pin is connected correctly."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Return type"})," None"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"get_clock()"})," (",(0,s.jsx)(t.em,{children:"Hardware diagnostic method"}),") Get the current time."]}),"\n",(0,s.jsxs)(t.p,{children:["The purpose of this function is to check that the free-running counter has been initialized properly and is counting correctly. ",(0,s.jsx)(t.strong,{children:"Note"}),": this is the free-running counter used internally by the CANHack toolkit to measure time and is not the same as the timer inside the CAN controller on the CANPico board used for timestamping."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Returns"})," the current time in pre-scaled CPU clock ticks"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Return type"})," int"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"reset_clock()"})}),"\n",(0,s.jsxs)(t.p,{children:["(",(0,s.jsx)(t.em,{children:"Hardware diagnostic method"}),") Reset the free-running counter to zero."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Return type"})," None\r\n",(0,s.jsx)(t.strong,{children:"send_raw()"})," (",(0,s.jsx)(t.em,{children:"Hardware diagnostic method"}),") Send the raw bitstream of a CAN frame on the CAN TX pin."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Return type"})," None"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Raises"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"ValueError"})," \u2013 if the frame buffer has not been set by a prior call to ",(0,s.jsx)(t.em,{children:"set_frame"}),"()"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The CAN frame to send must have been set with a call to set_frame() before calling this method. This call does not enter into CAN arbitration or participate in the CAN protocol, it merely sends a sequence of bits to the pin. Consequently, the CAN bus must be idle when this function is called."}),"\n",(0,s.jsx)(t.h3,{id:"63-quick-start",children:"6.3 Quick start"}),"\n",(0,s.jsx)(t.p,{children:"Connect to the board using a terminal emulator (minicom, PuTTY, rshell, etc.) to get a REPL prompt (use the first serial port \u2013 typically /dev/ttyACM0 on Linux \u2013 not the second one, which is reserved for MIN)."}),"\n",(0,s.jsx)(t.p,{children:"At the REPL prompt, bring in the CANHack API, create an instance of the toolkit, define a frame to send, check its bit pattern, then send it on the CAN bus:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:">>> from rp2 import *\r\n>>> ch = CANHack()\r\n>>> ch.set_frame(can_id=0x123, data=b'hello')\r\n>>> ch.print_frame()\r\n0001001000110000101011010000110010101101100011011000110111100111\r\n000001000111011111111111\r\n>>> ch.send_frame()\n"})}),"\n",(0,s.jsx)(t.p,{children:"This transmits a \u2018hello world\u2019 CAN frame on the bus. You can see this on the bus with a bus analyzer, logic analyzer8 or other receiver. Here\u2019s a CANPico receiving the frame:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:">>> frames = c.recv()\r\n>>> frames[0]\r\nCANFrame(CANID(id=S123), dlc=5, data=68656c6c6f, timestamp=130795841)\r\n>>> fames[0].get_data()\r\nb'hello'\n"})}),"\n",(0,s.jsx)(t.p,{children:"Note that a real CAN controller on an empty bus will transmit a frame forever in a loop because no receiver asserts a dominant in the ACK bit. The CANHack toolkit is not a CAN controller and doesn\u2019t bother following all the rules of CAN (attackers don\u2019t have to follow the rules..) so doesn\u2019t check its own ACK field reads back as dominant (it does check to see if its own bits are overwritten by an error frame or it loses arbitration \u2013 some rules are important enough to follow)."}),"\n",(0,s.jsx)(t.p,{children:"If the frame is received then everything is connected up OK. If not then possible causes of failure are:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The bit rate is wrong (CANHack defaults to 500Kbit/sec but can run at 250Kbit/sec and 125Kbit/sec)"}),"\n",(0,s.jsx)(t.li,{children:"The CAN H/L bus connections are bad: either loose or crossed"}),"\n",(0,s.jsx)(t.li,{children:"The bus isn\u2019t properly terminated (if the board is one end of the bus then its on- board termination should be activated, but not if the ends of the bus are already terminated)"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["See ",(0,s.jsx)(t.a,{href:"https://kentindell.github.io/2021/06/28/pulseview-raspberry-pi/",children:"https://kentindell.github.io/2021/06/28/pulseview-raspberry-pi/"})," for how to build the Pulseview logic analyzer on a Raspberry Pi and installing the Canis Labs can2 CAN protocol decoder"]})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},3393:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/mc-5e268c3e60b019e32cf2e193fafb4fe4.jpg"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(6540);const s={},i=r.createContext(s);function o(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);