{"searchDocs":[{"title":"A Tour of OBD-Kill Hardware","type":0,"sectionRef":"#","url":"/docs/obd-kill/a-tour-of-obd-kill-hardware/","content":"","keywords":"OBD-Kill OBD-Kill hardware OBD-Kill pinout GPIO pins CAN interface Pulse Width Modulator LEDs buttons circuit board automotive diagnostics","version":"Next"},{"title":"3. A Tour of OBD-Kill Hardware​","type":1,"pageTitle":"A Tour of OBD-Kill Hardware","url":"/docs/obd-kill/a-tour-of-obd-kill-hardware/#3-a-tour-of-obd-kill-hardware","content":" ","version":"Next","tagName":"h2"},{"title":"3.1 Case and Overall Design​","type":1,"pageTitle":"A Tour of OBD-Kill Hardware","url":"/docs/obd-kill/a-tour-of-obd-kill-hardware/#31-case-and-overall-design","content":" The OBD-Kill is enclosed in a lightweight circuit board. 13 LEDs, 2 buttons, CAN interface, and a Pulse Width Modulator are all built into this board. They can be easily controlled by using the Pin class and the pin numbers listed below.  ","version":"Next","tagName":"h3"},{"title":"3.2 Front Side and Pinout of Case​","type":1,"pageTitle":"A Tour of OBD-Kill Hardware","url":"/docs/obd-kill/a-tour-of-obd-kill-hardware/#32-front-side-and-pinout-of-case","content":"   Note The pinout printed on the OBD-Kill for the Left and Right Buttons is reversed. The correct GPIO Pin for the left button is Pin 18 and the correct GPIO Pin for the right button is Pin 15.  ","version":"Next","tagName":"h3"},{"title":"3.3 Back Side and Pinout of Case​","type":1,"pageTitle":"A Tour of OBD-Kill Hardware","url":"/docs/obd-kill/a-tour-of-obd-kill-hardware/#33-back-side-and-pinout-of-case","content":"   Note The pinout printed on the OBD-Kill for the Pusle Width Modulator (Buzzer) is incorrect. The correct GPIO Pin is 20. ","version":"Next","tagName":"h3"},{"title":"Safety and Other Important Notices","type":0,"sectionRef":"#","url":"/docs/obd-kill/safety-and-other-important-notices/","content":"","keywords":"neoVI PI Open Raspberry PI","version":"Next"},{"title":"1. Safety and Other Important Notices​","type":1,"pageTitle":"Safety and Other Important Notices","url":"/docs/obd-kill/safety-and-other-important-notices/#1-safety-and-other-important-notices","content":" Safety Notices Prior to using this product, read, understand, and follow the instructions for this device and any associated software. If you do not fully understand the instructions, contact icssupport@intrepidcs.com for support.Do not use this product if it has been used outside of the specified operating conditions or is suspected to be damaged.There are no operator serviceable parts inside this equipment. Should you suspect the device is not operating properly, please contact icssupport@intrepidcs.comThe failure modes of this device should be carefully considered prior to using it to instrument safety critical systems. A single point of failure at this device should not prevent the safe operation of any vehicle system.Occasionally, hardware and software are released for testing and evaluation in a beta release. These releases are not subject to full Quality Assurance. They should be used only in a controlled environment with consideration of any impact the safety of the user and the surrounding people and environment. Data and test results from beta hardware and software should be appropriately scrutinized.  Intended Use This hardware is intended for the use of developing automotive communication networks. It is suitable for operation in dry environments such as the passenger compartment or trunk area. Direct exposure to water or excessively damp environments may result in malfunction or damage to the device. Deviating from the intended use of this product or operating outside of its specifications may cause malfunction or damage and will void the manufacturer’s warranty.  Disclaimers Every attempt is made to keep this documentation accurate and current. Intrepid Control Systems reserves the right to update this documentation without notice and assumes no liability from its use. ","version":"Next","tagName":"h3"},{"title":"OBD-Kill","type":0,"sectionRef":"#","url":"/docs/obd-kill/","content":"OBD-Kill Defcon Car Hacking Village Badge – Raspberry Pi Pico-Powered Automotive Hacking Badge​ OBD-Kill hardware test","keywords":"Defcon CHV badge Car Hacking Village badge Raspberry Pi Pico badge CAN bus hacking automotive cybersecurity Defcon hacker badge car hacking tool Defcon badge hacking","version":"Next"},{"title":"Setup","type":0,"sectionRef":"#","url":"/docs/obd-kill/hardware-and-software-setup/","content":"","keywords":"OBD-Kill UF2 file Raspberry Pi Pico bootloader mode firmware update CAN Hack UF2 micro USB RPI-RP2 flashing firmware Defcon 30","version":"Next"},{"title":"4. How to download a UF2 File to your OBD-Kill​","type":1,"pageTitle":"Setup","url":"/docs/obd-kill/hardware-and-software-setup/#4-how-to-download-a-uf2-file-to-your-obd-kill","content":" Download the CAN Hack UF2 File at https://cdn.intrepidcs.net/guides/OBD-Kill/defcon30_uf2.zip  ","version":"Next","tagName":"h3"},{"title":"4.1 CONNECT THE OBD-Kill PICO TO YOUR COMPUTER​","type":1,"pageTitle":"Setup","url":"/docs/obd-kill/hardware-and-software-setup/#41-connect-the-obd-kill-pico-to-your-computer","content":" Connect the micro USB cable to your host computer.Connect the other end of the micro USB cable to the Pico while you press and hold the BOOTSEL button on the Pico. This will cause the Raspberry Pi Pico to enter bootloader mode and allow you to upload a new UF2 File.    Release the button once the cable is connected.  A disk volume called RPI-RP2 will appear on your computer.  ","version":"Next","tagName":"h3"},{"title":"4.2 Load a UF2 File to the Raspberry Pi Pico​","type":1,"pageTitle":"Setup","url":"/docs/obd-kill/hardware-and-software-setup/#42-load-a-uf2-file-to-the-raspberry-pi-pico","content":" Open RPI-RP2 on your computer by double-clicking it.Drag and drop the .uf2 file that you downloaded earlier.  RPI-RP2 will unmount and the LEDs on your OBD-Kill will start blinking  You’ve just uploaded the first bit of code to your Pico! ","version":"Next","tagName":"h3"},{"title":"Support Contact Information","type":0,"sectionRef":"#","url":"/docs/obd-kill/support-contact-information/","content":"","keywords":"neoVI PI Open Raspberry PI Support Contact Information","version":"Next"},{"title":"9. Support Contact Information​","type":1,"pageTitle":"Support Contact Information","url":"/docs/obd-kill/support-contact-information/#9-support-contact-information","content":" If you have questions on our products or your application, we are here to help. Feel free to contact ICS for assistance at one of our offices.  ","version":"Next","tagName":"h2"},{"title":"9.1. USA Headquarters​","type":1,"pageTitle":"Support Contact Information","url":"/docs/obd-kill/support-contact-information/#91-usa-headquarters","content":" Live support is available from 8 am to 8 pm, Monday to Friday, Eastern Standard / Daylight Time (EST/EDT).  Phone: (800) 859-6265 or (586) 731-7950, extension 1  They can also be contacted at any time through our Talk to an Expert page.  Regardless of the method of contact, our support team will get back to you as soon as possible.  ","version":"Next","tagName":"h3"},{"title":"9.2. ICS International Offices​","type":1,"pageTitle":"Support Contact Information","url":"/docs/obd-kill/support-contact-information/#92-ics-international-offices","content":" For support in other regions, please refer to our website which lists the latest info for our other offices:  https://www.intrepidcs.com/worldwide/  Support is normally provided from 0900-1700 in the time zone of your local office. You can also contact our headquarters in the USA if your region is not listed. ","version":"Next","tagName":"h3"},{"title":"Introduction and Overview","type":0,"sectionRef":"#","url":"/docs/obd-kill/introduction-and-overview/","content":"","keywords":"OBD-Kill Intrepid Control Systems CAN Tx Raspberry Pi Pico car hacking PWM LEDs programmable buttons CHV badge Defcon automotive diagnostics","version":"Next"},{"title":"2. Introduction and Overview​","type":1,"pageTitle":"Introduction and Overview","url":"/docs/obd-kill/introduction-and-overview/#2-introduction-and-overview","content":" ","version":"Next","tagName":"h2"},{"title":"2.1 Introduction​","type":1,"pageTitle":"Introduction and Overview","url":"/docs/obd-kill/introduction-and-overview/#21-introduction","content":" Thank you for purchasing an Intrepid Control Systems OBD-Kill tool. Intrepid Control Systems teamed up with Defcon Car Hacking Village to bring you a CHV themed badge. The badge will make your Defcon experience more memorable by allowing you to generate arbitrary CAN waves, make some noise with built in Buzzer, show lots of cool LEDs and you can hack everything about the badge using Raspberry Pi Pico.  ","version":"Next","tagName":"h3"},{"title":"2.2 Package Contents​","type":1,"pageTitle":"Introduction and Overview","url":"/docs/obd-kill/introduction-and-overview/#22-package-contents","content":" If you purchase the OBD-Kill from the Defcon 30 Car Hacking Village then you will have received an OBD-Kill badge with Lithium 3-volt coin battery.  ","version":"Next","tagName":"h3"},{"title":"2.3 Operational Overview​","type":1,"pageTitle":"Introduction and Overview","url":"/docs/obd-kill/introduction-and-overview/#23-operational-overview","content":" With a Raspberry Pi Pico, the uses are infitite! However, this isn't just a Raspberry Pi Pico, your OBD-Kill has built in programmable LEDs, Pulse Width Modulator (PWM), and CAN Tx capabilities. Plus, using the General Purpose IO pins, you're not limited to the to your OBD-Kill; you can connect to other OBD-Kills, LCD screens, sensors, and more!  Additionally, an optional 3-volt coin battery gives you the flexibility to use the LEDs on your OBD-Kill without having to connect to a computer.  ","version":"Next","tagName":"h3"},{"title":"2.4 Block Diagram​","type":1,"pageTitle":"Introduction and Overview","url":"/docs/obd-kill/introduction-and-overview/#24-block-diagram","content":" Front Side -  OBD-KIll front view  Back Side -  OBD-KIll back view  ","version":"Next","tagName":"h3"},{"title":"2.5 Summary of Key Features​","type":1,"pageTitle":"Introduction and Overview","url":"/docs/obd-kill/introduction-and-overview/#25-summary-of-key-features","content":" 1x CAN channel12 LEDs2x Programmable Buttons1x Pulse Width Modulator (Buzzer)Compatible with Raspberry Pi Pico development including C/C++, Micro Python and others. USB console app for generating arbitrary CAN messages with 8ns timing resolutionOpen source schematic and example programsCHV talkvideo explaining function and use of badgeDip SwitchLithium 3-volt coin battery  ","version":"Next","tagName":"h3"},{"title":"2.6 Hardware and Software Requirements​","type":1,"pageTitle":"Introduction and Overview","url":"/docs/obd-kill/introduction-and-overview/#26-hardware-and-software-requirements","content":" Micro USB cable for power and configuration ","version":"Next","tagName":"h3"},{"title":"CANHack MicroPython SDK","type":0,"sectionRef":"#","url":"/docs/obd-kill/canhack-micropython-sdk/","content":"","keywords":"CANHack MicroPython SDK CAN bus security testing Raspberry Pi Pico spoofing bus-off error injection","version":"Next"},{"title":"6. CANHack MicroPython SDK​","type":1,"pageTitle":"CANHack MicroPython SDK","url":"/docs/obd-kill/canhack-micropython-sdk/#6-canhack-micropython-sdk","content":" ","version":"Next","tagName":"h3"},{"title":"6.1 Introduction​","type":1,"pageTitle":"CANHack MicroPython SDK","url":"/docs/obd-kill/canhack-micropython-sdk/#61-introduction","content":" There are two ways to mount an attack on a CAN bus. The simplest is a frame attack: to use existing CAN hardware – the CAN controller – to send frames on the bus. For example, to send a spoof frame. Or to send frames at such a rate that legitimate frames are slowed or prevented: a flood attack (in a real-time system, a message arriving late is a failure of the system). The other way to mount an attack is to by-pass the CAN hardware and drive carefully crafted signals directly on to the bus: a CAN protocol attack.  A CAN protocol attack uses software to drive signals that exploit low-level features of the CAN protocol itself. For example, the Bus Off attack uses the CAN error confinement rules to disconnect a targeted ECU from the bus. A CAN protocol attack uses direct access to the standard component that all ECUs contain: the CAN transceiver. The transceiver is a chip that converts between the digital TX and RX I/O from the CAN controller and the analog voltages of CAN H and CAN L on the twisted pair CAN wire. Normally the TX and RX pins are driven by a CAN controller but in most ECU electronics this controller is integrated inside a single microcontroller chip alongside the CPU, RAM, etc. But software can disable the CAN controller and take control of the I/O pins directly (using the pin mux that is present in some form on all microcontrollers).    With carefully written software it is possible to drive the TX pin quickly enough to emulate parts of the CAN protocol and mount protocol attacks. The CANHack toolkit is designed to prove that this is a viable attack mechanism.  The CANHack software is provided as generic C that ‘bit bangs’ the TX pin using spin loops. It has been ported to the RP2040 microcontroller in the Raspberry Pi Pico and been wrapped with a Python API in custom MicroPython firmware for the Raspberry Pi Pico, and firmware is provided for three different boards:  The Canis Labs (canislabs.com) CANPico board1, that has a CAN transceiver shared with a Microchip MCP2517FD CAN controller connected over SPI.The Canis Labs CANHack board.The Car Hacking Village DEF CON 30 badge from Intrepid Control Systems (intrepidcs.com)  The generic C and the MicroPython API code are available in the Canis Labs repository: https://github.com/kentindell/canhack  See https://kentindell.github.io/2021/05/24/canpico-intro/ for more about the CANPico  The CANHack toolkit attacks implements the following attacks:  Targeted and overwrite spoofing attacksBus Off attackError Passive attackJanus2 attackDouble Receive3 attackFreeze Doom Loop4 attack  The API also contains diagnostic functions for setting the bus to dominant or recessive, putting a square wave on to the bus, and sending a defined CAN frame.  As well as providing the CANHack toolkit API there are some other features included in the firmware:  - A second USB serial port is included (so when the Pico connects to a host, two virtual ports are instantiated5).  - An implementation of the MIN (Microcontroller Interconnect Network) protocol6.  Before going any further there is an important caveat:  WARNING Connecting the CAN hardware directly to a vehicle CAN bus comes with risk and should not be undertaken without understanding this risk. Grounding a vehicle chassis through the USB port of a Pico connected to a laptop, PC or USB hub powered from the mains may cause permanent damage to the vehicle’s electronics and/or the Raspberry Pi Pico and devices it is connected to. The CAN transceiver will tolerate a ground potential difference (“ground offset”) of between -2V/+7V. Connecting pin 2 of the screw terminal to the target system’s ground will establish a common ground reference. The CAN bus must be properly terminated (with 120W resistors at either end). If the CAN bus is already terminated at both ends then the termination on the board should not be engaged. In addition, causing disruption to a vehicle’s CAN bus traffic may be interpreted by the vehicle fault management systems as a hardware fault and cause the vehicle to permanently shut down CAN communications with consequent loss of functionality.  ","version":"Next","tagName":"h3"},{"title":"6.2 CANHack Python API​","type":1,"pageTitle":"CANHack MicroPython SDK","url":"/docs/obd-kill/canhack-micropython-sdk/#62-canhack-python-api","content":" The CANHack toolkit is provided as a single class CANHack.  6.2.1 CANHack — CANHack toolkit  class CANHack( [ bitrate=500 ] )  Initializes the CANHack toolkit.  info If running on a CANPico, this constructor must be called after the CAN controller TX output is put into open drain mode (by setting the CAN controller tx_open_drain parameter to True).  Raises  ValueError – if bit_rate is not one of 500, 250, or 125  Methods  set_frame([can_id=0x7ff] [, remote=False] [, extended=False] [, data=None] [, set_dlc=False] [, dlc=0] [, second=False] )  Set the specified frame buffer.  The frame buffer is an internal buffer in RAM in the toolkit that pre-defines the bit sequence for a CAN frame (pre-calculating where the stuff bits go, etc.)  This function pre-computes the layout of a CAN frame into a frame buffer inside the toolkit (it will set the shadow frame buffer is second is True because the Janus Attack7 requires two separate CAN frames).  This method must be called prior to mounting an attack: the pre-computed bit pattern in the frame buffer is used to synchronize the attack on a targeted frame.  Parameters  can_id (int)– An 11-bit or 29-bit integer representing the CAN ID of the frameremote (bool) – True if the frame is a remote frameextended (bool) – True if can_id is a 29-bit CAN identifierdata (bytes) – The payload of the CAN frameset_dlc (bool) – True if the DLC should be set to a specific valuedlc (int) – the value of DLC if set_dlc is Truesecond (bool) – True if this call is setting the shadow frame in preparation for the Janus Attack  Raises  ValueError – if the dlc value is &gt; 15 or if the payload is more than 8 bytes or remote is True and data is set  For more details on the Janus Attack see: https://kentindell.github.io/2020/01/20/new-can-hacks/  Returns None  get_frame( [, second=False] )  Return details of the specified frame buffer.  Parameters  second (bool) – True if the details of the shadow frame buffer should be returned  Return type tupleRaises  ValueError – if the selected frame buffer has not been set by a prior call to set_frame()  The method returns an 8-element tuple of:  - A string representing the frame bitstream (including stuff bits) with '1' and '0' characters for the bits  - A string representing where the stuff bits are located (with 'X' being a stuff bit and '–' being a data bit)  - The integer index of the last arbitration bit in the bitstream  - The integer index of the last DLC bit in the bitstream  - The integer index of the last data bit in the bitstream  - The integer index of the last CRC bit in the bitstream  - The integer index of the last EOF bit in the bitstream  - A 15-bit integer of the CRC of the frame  send_frame([timeout=50000000] [, second=False] [, retries=0])  Send a frame on the CAN bus.  Parameters  timeout (int) – A value for how long we wait for bus idle before giving up  second (bool) – True if the frame should come from the shadow frame buffer  retries (int) – the number of times to try again to send the frame after loss of arbitration or error  Raises  ValueError – if the selected frame buffer has not been set by a prior call to set_frame()  This function sends the specified frame on the CAN bus. It waits for the bus to become idle and then starts transmitting, following the CAN protocol for arbitration. If it loses arbitration or detects an error then it tries again, up to a maximum set by retries.  This function can mount a traditional spoof attack on the bus where the frame pretends to be from another node, avoiding the 'doom loop' problem with this being mounted from a standard CAN controller (the 'doom loop' happens if the spoof frame and the legitimate frame happen to win arbitration at the same time: an error will be raised and arbitration will re-start and his will continue in a loop until one of the devices has gone error passive or bus-off).  The timeout value is used as a limit on spin looping and depends on the target CPU. For the RP2040 in the Raspberry Pi Pico a timeout value of 3440000 is one second of real-time.  send_janus_frame([timeout=50000000] [, sync_time=50] [, split_time=155], [, retries=0])  Sends the specified Janus frame on the CAN bus.  It waits for the bus to become idle and then starts transmitting, following the CAN protocol for arbitration. If it loses arbitration or detects an error then it tries again, up to a maximum set by retries.  A Janus frame is a CAN frame with two different contents, specified by the frame buffer and shadow frame buffer. It must have the same ID and be the same number of bits long, which means it must have the same number of stuff bits (although they can be in different places).  There is a Python tool in the Canis Labs CANHack repository (https://github.com/kentindell/canhack) in src/canframe.py. The function is_janus() indicates if two frames are ‘Janus compatible’: checking the length is the same and also the transitions cause the CAN protocol engines in the receivers to sync correctly. There is also code that does a search for compatible Janus frames.  Parameters  timeout (int) – The timeout (a value of 50000000 corresponds to about 17 seconds on the Raspberry Pi Pico)sync_time (int) – The number of clock ticks to wait to ensure controllers have syncedsplit_time (int) – The number of clock ticks from the start of the bit before the second CAN bit value is setretries (int) – the number of times to try to send the frame after loss of arbitration or error  Raises  ValueError – if either frame buffer has not been set by a prior call to set_frame()  spoof_frame([timeout=50000000] [, overwrite=False] [, retries=0])  Target a frame and send a spoof version.  Parameters  timeout (int) – The time to wait for the targeted frame to appear before giving upoverwrite (bool) – Once the targeted frame has been detected, overwrite the remainder with the selected spoof frame retries (int) – the number of times to try to send the frame after loss of arbitration or error  Returns None  Raises  ValueError – if the frame buffer has not been set by a prior call to set_frame()  If overwrite is True then the spoof frame is written over the top of the targeted frame. If the targeted sender is error passive then it will not be able to signal an error frame and other controllers will receive only the spoofed version of the frame. If overwrite is set to False then the spoof frame is entered into arbitration immediately following the end of the targeted frame.  error_attack([repeat=2] [, timeout=50000000])  Repeatedly destroy a targeted frame with error frames.  Parameters  timeout (int) – The time to wait for the targeted frame to appear before giving uprepeat (int) – the number of times to repeat the attack  Returns True if the timeout occurred, False otherwise  Return type boolRaises  ValueError – if the frame buffer has not been set by a prior call to set_frame()  A CAN frame with the targeted frame's ID must be set using the set_frame() before calling this method. When the ID of the targeted CAN frame has been seen then an error is generated (six dominant bits) and all CAN controllers go into error handling. The error delimiter is targeted for further repeating of the attack. With this approach a targeted node can quickly be driven into the error passive or bus- off state.  double_receive_attack([repeat=2] [, timeout=50000000])  Cause a targeted frame to be received twice.  Parameters  timeout (int) – The time to wait for the targeted frame to appear before giving uprepeat (int) – the number of times to repeat the attack  Returns True if the timeout occurred, False otherwise  Return type boolRaises  ValueError – if the frame buffer has not been set by a prior call to set_frame()  A CAN frame with the targeted frame's ID must be set using the set_frame() before calling this method. When the ID of the targeted CAN frame has been seen then an error is generated at the last bit of the EOF field, after the receivers have accepted the CAN frame but before the transmitter has marked it as sent. This causes the transmitter to signal an error and retransmit the frame, leading to it being received twice.  freeze_doom_loop_attack([repeat=2] [, timeout=50000000])  Freeze the bus after a targeted frame has been successfully transmitted.  Parameters  timeout (int) – The number of bit times to wait for the targeted frame to appear before giving uprepeat (int) – the number of times to repeat the attack  Returns None  Raises  ValueError – if the frame buffer has not been set by a prior call to set_frame()  A CAN frame with the targeted frame's ID must be set using the set_frame() before calling this method. When the ID of the targeted CAN frame has been seen then an overload frame is generated after the last bit of the EOF field, after the receivers have accepted the CAN frame and the transmitter has marked it as sent. This causes the controllers to enter the overload frame recovery mode (like error recovery, except the error counters are not incremented). At the end of the error delimiter, another overload frame is generated until the number in the repeat parameter is reached.  set_can_tx( [ recessive=True ] )  (Hardware diagnostic method) Set the CAN TX pin to recessive or dominant.  Parameters  recessive (bool) – Set to True if the TX pin should be set recessive (i.e. high)  Returns True if CAN RX was recessive, False otherwise  Return type bool  This is intended for diagnostics to check that the TX and RX pins have been identified and connected correctly.  square_wave()  (Hardware diagnostic method) Drive the CAN TX pin for 160 CAN bit times with a square wave with a 50:50 duty cycle and a frequency of half the CAN bit rate.  The purpose of this function is for hardware bring-up to check that the CAN TX pin is driven correctly.  Return type None  loopback() (Hardware diagnostic method) Wait for a falling edge on CAN RX and then drive the TRIG pin with the value of CAN RX for 160 bit times.  The purpose of this function is for hardware bring-up to check that the CAN RX pin is connected correctly.  Return type None  get_clock() (Hardware diagnostic method) Get the current time.  The purpose of this function is to check that the free-running counter has been initialized properly and is counting correctly. Note: this is the free-running counter used internally by the CANHack toolkit to measure time and is not the same as the timer inside the CAN controller on the CANPico board used for timestamping.  Parameters  Returns the current time in pre-scaled CPU clock ticks  Return type int  reset_clock()  (Hardware diagnostic method) Reset the free-running counter to zero.  Return type Nonesend_raw() (Hardware diagnostic method) Send the raw bitstream of a CAN frame on the CAN TX pin.  Return type None  Raises  ValueError – if the frame buffer has not been set by a prior call to set_frame()  The CAN frame to send must have been set with a call to set_frame() before calling this method. This call does not enter into CAN arbitration or participate in the CAN protocol, it merely sends a sequence of bits to the pin. Consequently, the CAN bus must be idle when this function is called.  ","version":"Next","tagName":"h3"},{"title":"6.3 Quick start​","type":1,"pageTitle":"CANHack MicroPython SDK","url":"/docs/obd-kill/canhack-micropython-sdk/#63-quick-start","content":" Connect to the board using a terminal emulator (minicom, PuTTY, rshell, etc.) to get a REPL prompt (use the first serial port – typically /dev/ttyACM0 on Linux – not the second one, which is reserved for MIN).  At the REPL prompt, bring in the CANHack API, create an instance of the toolkit, define a frame to send, check its bit pattern, then send it on the CAN bus:  &gt;&gt;&gt; from rp2 import * &gt;&gt;&gt; ch = CANHack() &gt;&gt;&gt; ch.set_frame(can_id=0x123, data=b'hello') &gt;&gt;&gt; ch.print_frame() 0001001000110000101011010000110010101101100011011000110111100111 000001000111011111111111 &gt;&gt;&gt; ch.send_frame()   This transmits a ‘hello world’ CAN frame on the bus. You can see this on the bus with a bus analyzer, logic analyzer8 or other receiver. Here’s a CANPico receiving the frame:  &gt;&gt;&gt; frames = c.recv() &gt;&gt;&gt; frames[0] CANFrame(CANID(id=S123), dlc=5, data=68656c6c6f, timestamp=130795841) &gt;&gt;&gt; fames[0].get_data() b'hello'   Note that a real CAN controller on an empty bus will transmit a frame forever in a loop because no receiver asserts a dominant in the ACK bit. The CANHack toolkit is not a CAN controller and doesn’t bother following all the rules of CAN (attackers don’t have to follow the rules..) so doesn’t check its own ACK field reads back as dominant (it does check to see if its own bits are overwritten by an error frame or it loses arbitration – some rules are important enough to follow).  If the frame is received then everything is connected up OK. If not then possible causes of failure are:  The bit rate is wrong (CANHack defaults to 500Kbit/sec but can run at 250Kbit/sec and 125Kbit/sec)The CAN H/L bus connections are bad: either loose or crossedThe bus isn’t properly terminated (if the board is one end of the bus then its on- board termination should be activated, but not if the ends of the bus are already terminated)  See https://kentindell.github.io/2021/06/28/pulseview-raspberry-pi/ for how to build the Pulseview logic analyzer on a Raspberry Pi and installing the Canis Labs can2 CAN protocol decoder ","version":"Next","tagName":"h3"},{"title":"OBD-Kill MicroPython Examples","type":0,"sectionRef":"#","url":"/docs/obd-kill/obd-kill-micropython-examples/","content":"","keywords":"OBD-Kill MicroPython Raspberry Pi Pico GPIO PWM UART LED control pinout CAN Hack serial communication buzzer Pulse Width Modulation UF2 file.","version":"Next"},{"title":"5. Examples​","type":1,"pageTitle":"OBD-Kill MicroPython Examples","url":"/docs/obd-kill/obd-kill-micropython-examples/#5-examples","content":" ","version":"Next","tagName":"h2"},{"title":"5.1 Pin​","type":1,"pageTitle":"OBD-Kill MicroPython Examples","url":"/docs/obd-kill/obd-kill-micropython-examples/#51-pin","content":" A pin object is used to control I/O pins (also known as GPIO - general-purpose input/output). Pin objects are commonly associated with a physical pin that can drive an output voltage and read input voltages. The pin class has methods to set the mode of the pin (IN, OUT, etc) and methods to get and set the digital logic level. For analog control of a pin, see the ADC class.  A pin object is constructed by using an identifier which unambiguously specifies a certain I/O pin. The allowed forms of the identifier and the physical pin that the identifier maps to are port-specific. Possibilities for the identifier are an integer, a string or a tuple with port and pin number.  from machine import Pin # create an output pin on pin #0 p0 = Pin(0, Pin.OUT) # set the value low then high p0.value(0) p0.value(1) # create an input pin on pin #2, with a pull up resistor p2 = Pin(2, Pin.IN, Pin.PULL_UP) # read and print the pin value print(p2.value()) # reconfigure pin #0 in input mode with a pull down resistor p0.init(p0.IN, p0.PULL_DOWN) # configure an irq callback p0.irq(lambda p:print(p))   Pin values can be set; however, Signals are easier to control  ","version":"Next","tagName":"h3"},{"title":"5.2 Signal (used for LEDs)​","type":1,"pageTitle":"OBD-Kill MicroPython Examples","url":"/docs/obd-kill/obd-kill-micropython-examples/#52-signal-used-for-leds","content":" https://docs.micropython.org/en/latest/library/machine.Signal.html  The Signal class is a simple extension of the Pin class. Unlike Pin, which can be only in “absolute” 0 and 1 states, a Signal can be in “asserted” (on) or “deasserted” (off) states, while being inverted (active-low) or not. In other words, it adds logical inversion support to Pin functionality. While this may seem a simple addition, it is exactly what is needed to support wide array of simple digital devices in a way portable across different boards, which is one of the major MicroPython goals. Regardless of whether different users have an active-high or active-low LED, a normally open or normally closed relay - you can develop a single, nicely looking application which works with each of them, and capture hardware configuration differences in few lines in the config file of your app.  The following example shows how to create signals to control the inner LED on both eyes of the OBD-Kill  from machine import Signal import utime rightMiddlePin = Pin(10, Pin.OUT) rightMiddleLED = Signal(rightMiddlePin) # can combine constructor to one leftMiddleLED = Signal(Pin(26, Pin.OUT) rightMiddleLED.on() leftMiddleLED.off() # .value() returns the status of the LED (On=1, Off=0) print(rightMiddleLED.value()) # will print 1 print(leftMiddleLED.value()) # will print 0 # alternate flashing each green LED every second while True: rightMiddleLED.on() leftMiddleLED.off() utime.sleep_ms(1000) rightMiddleLED.on() leftMiddleLED.off() utime.sleep_ms(1000)   ","version":"Next","tagName":"h3"},{"title":"5.3 PWM – Pulse Width Modulation​","type":1,"pageTitle":"OBD-Kill MicroPython Examples","url":"/docs/obd-kill/obd-kill-micropython-examples/#53-pwm--pulse-width-modulation","content":" This class provides pulse width modulation output  https://docs.micropython.org/en/latest/library/machine.PWM.html  Here is a Map that contains the pitches and their corresponding frequencies. See the next example to see how to access the frequency.  tones = {&quot;B0&quot;: 31, &quot;C1&quot;: 33, &quot;CS1&quot;: 35, &quot;D1&quot;: 37, &quot;DS1&quot;: 39, &quot;E1&quot;: 41, &quot;F1&quot;: 44, &quot;FS1&quot;: 46, &quot;G1&quot;: 49, &quot;GS1&quot;: 52, &quot;A1&quot;: 55, &quot;AS1&quot;: 58, &quot;B1&quot;: 62, &quot;C2&quot;: 65, &quot;CS2&quot;: 69, &quot;D2&quot;: 73, &quot;DS2&quot;: 78, &quot;E2&quot;: 82, &quot;F2&quot;: 87, &quot;FS2&quot;: 93, &quot;G2&quot;: 98, &quot;GS2&quot;: 104, &quot;A2&quot;: 110, &quot;AS2&quot;: 117, &quot;B2&quot;: 123, &quot;C3&quot;: 131, &quot;CS3&quot;: 139, &quot;D3&quot;: 147, &quot;DS3&quot;: 156, &quot;E3&quot;: 165, &quot;F3&quot;: 175, &quot;FS3&quot;: 185, &quot;G3&quot;: 196, &quot;GS3&quot;: 208, &quot;A3&quot;: 220, &quot;AS3&quot;: 233, &quot;B3&quot;: 247,&quot;C4&quot;: 262, &quot;CS4&quot;: 277, &quot;D4&quot;: 294, &quot;DS4&quot;: 311, &quot;E4&quot;: 330, &quot;F4&quot;: 349, &quot;FS4&quot;: 370, &quot;G4&quot;: 392, &quot;GS4&quot;: 415, &quot;A4&quot;: 440, &quot;AS4&quot;: 466, &quot;B4&quot;: 494, &quot;C5&quot;: 523, &quot;CS5&quot;: 554, &quot;D5&quot;: 587, &quot;DS5&quot;: 622, &quot;E5&quot;: 659, &quot;F5&quot;: 698, &quot;FS5&quot;: 740, &quot;G5&quot;: 784, &quot;GS5&quot;: 831, &quot;A5&quot;: 880, &quot;AS5&quot;: 932, &quot;B5&quot;: 988, &quot;C6&quot;: 1047, &quot;CS6&quot;: 1109, &quot;D6&quot;: 1175, &quot;DS6&quot;: 1245,&quot;E6&quot;: 1319, &quot;F6&quot;: 1397, &quot;FS6&quot;: 1480, &quot;G6&quot;: 1568, &quot;GS6&quot;: 1661, &quot;A6&quot;: 1760, &quot;AS6&quot;: 1865, &quot;B6&quot;: 1976, &quot;C7&quot;: 2093, &quot;CS7&quot;: 2217, &quot;D7&quot;: 2349, &quot;DS7&quot;: 2489, &quot;E7&quot;: 2637, &quot;F7&quot;: 2794, &quot;FS7&quot;: 2960, &quot;G7&quot;: 3136, &quot;GS7&quot;: 3322, &quot;A7&quot;: 3520, &quot;AS7&quot;: 3729, &quot;B7&quot;: 3951, &quot;C8&quot;: 4186, &quot;CS8&quot;: 4435, &quot;D8&quot;: 4699, &quot;DS8&quot;: 4978, &quot;rest&quot;: -1}py   The duty cycle is set by using the .duty_u16() method. This value is divided by 65535 to calculate the duty cycle. A larger number corresponds with a louder volume.  Warning Use caution when programming large duty cycles. Loud sounds may cause hearing damage. For these examples, the duty cycle will never exceed 1000.  buzzer.freq(tones[&quot;C5&quot;]) # set the frequency to match pitch C5 buzzer.duty_u16(2000) # set the duty cycle for the pulses to be 1000/65535=1.5%   Increase the volume (duty cycle) for 3 seconds, hold for 3 seconds, decrease the volume for 3 seconds  for i in range(0, 1000): buzzer.duty_u16(i) utime.sleep_ms(3) utime.sleep_ms(3000) for i in reversed(range(0, 1000)): buzzer.duty_u16(i) utime.sleep_ms(3)   ","version":"Next","tagName":"h3"},{"title":"5.4 Serial Communication Interface​","type":1,"pageTitle":"OBD-Kill MicroPython Examples","url":"/docs/obd-kill/obd-kill-micropython-examples/#54-serial-communication-interface","content":" UART implements the standard UART/USART duplex serial communications protocol. At the physical level it consists of 2 lines: RX and TX. The unit of communication is a character (not to be confused with a string character) which can be 8 or 9 bits wide.  https://docs.micropython.org/en/latest/library/machine.UART.html  UART objects can be created and initialised using:  from machine import UART uartOne = UART(1, baudrate=9600, tx=Pin(4), rx=Pin(5)) # GP4 is the standard Pin for and transmitting messages is the standard Pin for receiving   A UART object acts like a stream object and reading and writing is done using the standard stream methods:  uart.read(10) # read 10 characters, returns a bytes object uart.read() # read all available characters uart.readline() # read a line uart.readinto(buf) # read and store into the given buffer uart.write('abc') # write the characters 'a', 'b', and 'c'   A function to transmit a user-defined message on a specified interval:  import utime from machine import UART def transmitMessages(occurances, timeBetween, message): for i in range(occurances): uart.write(message + &quot;\\n&quot;) utime.sleep_ms(timeBetween) transmitMessages(5, 50, &quot;Test&quot;) # transmit the message &quot;Test&quot; 5 times with 50 seconds between each message  ","version":"Next","tagName":"h3"}],"options":{"indexBaseUrl":true,"id":"default"}}